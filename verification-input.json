{
  "language": "Solidity",
  "sources": {
    "contracts/Prediction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PrizePoolPrediction is ReentrancyGuard, Ownable(msg.sender) {\n    \n    struct Prediction {\n        uint256 id;\n        string question;\n        string[] options; // e.g., [\"YES\", \"NO\"] or [\"Team A\", \"Team B\", \"Draw\"]\n        uint256 entryFee;\n        uint256 prizePool;\n        uint256 endTime;\n        uint256 resolutionTime;\n        bool resolved;\n        uint256 winningOption; // Index of winning option\n        bool active;\n        address creator; // Platform admin who created it\n        uint256 totalParticipants;\n    }\n    \n    struct UserPrediction {\n        uint256 option; // Index of chosen option\n        bool claimed;\n        uint256 timestamp;\n    }\n    \n    struct UserStats {\n        uint256 totalPredictions;\n        uint256 correctPredictions;\n        uint256 currentStreak;\n        uint256 longestStreak;\n        uint256 totalWinnings;\n        uint256 lastPredictionTime;\n        bool hasStreakSaver; // One-time streak protection\n    }\n    \n    // State variables\n    uint256 public predictionCounter;\n    uint256 public platformFee = 500; // 5% (basis points)\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public streakSaverPrice = 0.01 ether; // Price to buy streak protection\n    \n    mapping(uint256 => Prediction) public predictions;\n    mapping(uint256 => mapping(address => UserPrediction)) public userPredictions;\n    mapping(uint256 => mapping(uint256 => address[])) public optionParticipants; // predictionId => optionIndex => participants\n    mapping(uint256 => mapping(uint256 => uint256)) public optionCounts; // predictionId => optionIndex => count\n    mapping(address => uint256[]) public userParticipatedPredictions;\n    mapping(address => UserStats) public userStats; // User statistics and streaks\n    \n    // Leaderboard arrays (top 10)\n    address[] public streakLeaders;\n    address[] public winningsLeaders;\n    address[] public accuracyLeaders;\n    \n    // Events\n    event PredictionCreated(\n        uint256 indexed predictionId,\n        string question,\n        string[] options,\n        uint256 entryFee,\n        uint256 prizePool,\n        uint256 endTime\n    );\n    \n    event PredictionSubmitted(\n        uint256 indexed predictionId,\n        address indexed user,\n        uint256 option,\n        string optionText\n    );\n    \n    event PredictionResolved(\n        uint256 indexed predictionId,\n        uint256 winningOption,\n        string winningOptionText,\n        uint256 winnersCount\n    );\n    \n    event PrizesClaimed(\n        uint256 indexed predictionId,\n        address indexed user,\n        uint256 amount\n    );\n    \n    event PrizePoolIncreased(\n        uint256 indexed predictionId,\n        uint256 additionalAmount,\n        uint256 newTotal\n    );\n    \n    event StreakUpdated(\n        address indexed user,\n        uint256 newStreak,\n        bool isCorrect,\n        bool streakSaverUsed\n    );\n    \n    event StreakSaverPurchased(\n        address indexed user\n    );\n    \n    event LeaderboardUpdated(\n        address indexed user,\n        string leaderboardType\n    );\n    \n    constructor() {}\n    \n    // Create a new prediction (only owner/admin)\n    function createPrediction(\n        string memory _question,\n        string[] memory _options,\n        uint256 _entryFee,\n        uint256 _endTime,\n        uint256 _resolutionTime\n    ) external payable onlyOwner returns (uint256) {\n        require(_endTime > block.timestamp, \"End time must be in future\");\n        require(_resolutionTime > _endTime, \"Resolution time must be after end time\");\n        require(bytes(_question).length > 0, \"Question cannot be empty\");\n        require(_options.length >= 2, \"Must have at least 2 options\");\n        require(_entryFee > 0, \"Entry fee must be greater than 0\");\n        require(msg.value > 0, \"Must provide initial prize pool\");\n        \n        predictionCounter++;\n        \n        predictions[predictionCounter] = Prediction({\n            id: predictionCounter,\n            question: _question,\n            options: _options,\n            entryFee: _entryFee,\n            prizePool: msg.value,\n            endTime: _endTime,\n            resolutionTime: _resolutionTime,\n            resolved: false,\n            winningOption: 0,\n            active: true,\n            creator: msg.sender,\n            totalParticipants: 0\n        });\n        \n        emit PredictionCreated(\n            predictionCounter, \n            _question, \n            _options, \n            _entryFee, \n            msg.value, \n            _endTime\n        );\n        \n        return predictionCounter;\n    }\n    \n    // Submit a prediction\n    function submitPrediction(uint256 _predictionId, uint256 _optionIndex) \n        external \n        payable \n        nonReentrant \n    {\n        Prediction storage prediction = predictions[_predictionId];\n        require(prediction.active, \"Prediction not active\");\n        require(!prediction.resolved, \"Prediction already resolved\");\n        require(block.timestamp < prediction.endTime, \"Prediction period ended\");\n        require(_optionIndex < prediction.options.length, \"Invalid option\");\n        require(msg.value == prediction.entryFee, \"Incorrect entry fee\");\n        require(userPredictions[_predictionId][msg.sender].timestamp == 0, \"Already predicted\");\n        \n        // Record user's prediction\n        userPredictions[_predictionId][msg.sender] = UserPrediction({\n            option: _optionIndex,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        // Track participants for this option\n        optionParticipants[_predictionId][_optionIndex].push(msg.sender);\n        optionCounts[_predictionId][_optionIndex]++;\n        \n        // Update prediction stats\n        prediction.totalParticipants++;\n        prediction.prizePool += msg.value;\n        \n        // Track user participation\n        userParticipatedPredictions[msg.sender].push(_predictionId);\n        \n        // Update user stats\n        userStats[msg.sender].totalPredictions++;\n        userStats[msg.sender].lastPredictionTime = block.timestamp;\n        \n        emit PredictionSubmitted(\n            _predictionId, \n            msg.sender, \n            _optionIndex, \n            prediction.options[_optionIndex]\n        );\n    }\n    \n    // Resolve a prediction (only owner/admin)\n    function resolvePrediction(uint256 _predictionId, uint256 _winningOption) \n        external \n        onlyOwner \n    {\n        Prediction storage prediction = predictions[_predictionId];\n        require(prediction.active, \"Prediction not active\");\n        require(!prediction.resolved, \"Already resolved\");\n        require(block.timestamp >= prediction.endTime, \"Prediction period not ended\");\n        require(block.timestamp <= prediction.resolutionTime, \"Resolution period expired\");\n        require(_winningOption < prediction.options.length, \"Invalid winning option\");\n        \n        prediction.resolved = true;\n        prediction.winningOption = _winningOption;\n        \n        uint256 winnersCount = optionCounts[_predictionId][_winningOption];\n        \n        // Update streaks for all participants\n        _updateStreaksAfterResolution(_predictionId, _winningOption);\n        \n        emit PredictionResolved(\n            _predictionId, \n            _winningOption, \n            prediction.options[_winningOption],\n            winnersCount\n        );\n    }\n    \n    // Claim prize (winners only)\n    function claimPrize(uint256 _predictionId) external nonReentrant {\n        Prediction memory prediction = predictions[_predictionId];\n        require(prediction.resolved, \"Prediction not resolved\");\n        \n        UserPrediction storage userPred = userPredictions[_predictionId][msg.sender];\n        require(userPred.timestamp > 0, \"No prediction found\");\n        require(!userPred.claimed, \"Prize already claimed\");\n        require(userPred.option == prediction.winningOption, \"Not a winner\");\n        \n        userPred.claimed = true;\n        \n        uint256 winnersCount = optionCounts[_predictionId][prediction.winningOption];\n        require(winnersCount > 0, \"No winners\");\n        \n        // Calculate streak multiplier bonus\n        uint256 streakMultiplier = _calculateStreakMultiplier(msg.sender);\n        \n        // Calculate prize per winner\n        uint256 totalPrize = prediction.prizePool;\n        uint256 platformFeeAmount = (totalPrize * platformFee) / BASIS_POINTS;\n        uint256 winnersShare = totalPrize - platformFeeAmount;\n        uint256 basePrize = winnersShare / winnersCount;\n        uint256 finalPrize = (basePrize * streakMultiplier) / BASIS_POINTS;\n        \n        // Update user winnings stats\n        userStats[msg.sender].totalWinnings += finalPrize;\n        _updateLeaderboards(msg.sender);\n        \n        payable(msg.sender).transfer(finalPrize);\n        \n        emit PrizesClaimed(_predictionId, msg.sender, finalPrize);\n    }\n    \n    // Add more funds to prize pool (optional)\n    function increasePrizePool(uint256 _predictionId) external payable {\n        Prediction storage prediction = predictions[_predictionId];\n        require(prediction.active && !prediction.resolved, \"Prediction not active\");\n        require(msg.value > 0, \"Must send some ETH\");\n        \n        prediction.prizePool += msg.value;\n        \n        emit PrizePoolIncreased(_predictionId, msg.value, prediction.prizePool);\n    }\n    \n    // Buy streak saver protection\n    function buyStreakSaver() external payable {\n        require(msg.value >= streakSaverPrice, \"Insufficient payment\");\n        require(!userStats[msg.sender].hasStreakSaver, \"Already have streak saver\");\n        \n        userStats[msg.sender].hasStreakSaver = true;\n        \n        // Refund excess payment\n        if (msg.value > streakSaverPrice) {\n            payable(msg.sender).transfer(msg.value - streakSaverPrice);\n        }\n        \n        emit StreakSaverPurchased(msg.sender);\n    }\n    \n    // Internal function to update streaks after prediction resolution\n    function _updateStreaksAfterResolution(uint256 _predictionId, uint256 _winningOption) internal {\n        Prediction memory prediction = predictions[_predictionId];\n        \n        // Update streaks for all participants in this prediction\n        for (uint256 i = 0; i < prediction.options.length; i++) {\n            address[] memory participants = optionParticipants[_predictionId][i];\n            \n            for (uint256 j = 0; j < participants.length; j++) {\n                address participant = participants[j];\n                bool isCorrect = (i == _winningOption);\n                \n                UserStats storage stats = userStats[participant];\n                bool streakSaverUsed = false;\n                \n                if (isCorrect) {\n                    // Correct prediction - increment streak\n                    stats.correctPredictions++;\n                    stats.currentStreak++;\n                    \n                    // Update longest streak if current is higher\n                    if (stats.currentStreak > stats.longestStreak) {\n                        stats.longestStreak = stats.currentStreak;\n                    }\n                } else {\n                    // Wrong prediction - check for streak saver\n                    if (stats.hasStreakSaver && stats.currentStreak > 0) {\n                        // Use streak saver to maintain streak\n                        stats.hasStreakSaver = false;\n                        streakSaverUsed = true;\n                        // Streak remains the same\n                    } else {\n                        // Reset streak\n                        stats.currentStreak = 0;\n                    }\n                }\n                \n                emit StreakUpdated(participant, stats.currentStreak, isCorrect, streakSaverUsed);\n                \n                // Update leaderboards if necessary\n                _updateLeaderboards(participant);\n            }\n        }\n    }\n    \n    // Calculate streak multiplier for winnings\n    function _calculateStreakMultiplier(address _user) internal view returns (uint256) {\n        uint256 streak = userStats[_user].currentStreak;\n        \n        if (streak >= 10) return 20000; // 2x multiplier\n        if (streak >= 5) return 15000;  // 1.5x multiplier\n        if (streak >= 3) return 12000;  // 1.2x multiplier\n        return 10000; // 1x multiplier (no bonus)\n    }\n    \n    // Update leaderboards\n    function _updateLeaderboards(address _user) internal {\n        _updateStreakLeaderboard(_user);\n        _updateWinningsLeaderboard(_user);\n        _updateAccuracyLeaderboard(_user);\n    }\n    \n    function _updateStreakLeaderboard(address _user) internal {\n        uint256 userStreak = userStats[_user].currentStreak;\n        \n        // Find if user is already in leaderboard\n        for (uint256 i = 0; i < streakLeaders.length; i++) {\n            if (streakLeaders[i] == _user) {\n                // User already in leaderboard, check if needs reordering\n                _reorderStreakLeaderboard(i);\n                return;\n            }\n        }\n        \n        // User not in leaderboard, check if they qualify\n        if (streakLeaders.length < 10) {\n            // Leaderboard not full, add user\n            streakLeaders.push(_user);\n            _reorderStreakLeaderboard(streakLeaders.length - 1);\n        } else {\n            // Check if user's streak beats the lowest on leaderboard\n            uint256 lowestStreak = userStats[streakLeaders[9]].currentStreak;\n            if (userStreak > lowestStreak) {\n                streakLeaders[9] = _user;\n                _reorderStreakLeaderboard(9);\n            }\n        }\n        \n        emit LeaderboardUpdated(_user, \"streak\");\n    }\n    \n    function _reorderStreakLeaderboard(uint256 _startIndex) internal {\n        // Bubble up the user to their correct position\n        for (uint256 i = _startIndex; i > 0; i--) {\n            uint256 currentStreak = userStats[streakLeaders[i]].currentStreak;\n            uint256 previousStreak = userStats[streakLeaders[i-1]].currentStreak;\n            \n            if (currentStreak > previousStreak) {\n                // Swap positions\n                address temp = streakLeaders[i];\n                streakLeaders[i] = streakLeaders[i-1];\n                streakLeaders[i-1] = temp;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    function _updateWinningsLeaderboard(address _user) internal {\n        uint256 userWinnings = userStats[_user].totalWinnings;\n        \n        // Similar logic to streak leaderboard but for total winnings\n        for (uint256 i = 0; i < winningsLeaders.length; i++) {\n            if (winningsLeaders[i] == _user) {\n                _reorderWinningsLeaderboard(i);\n                return;\n            }\n        }\n        \n        if (winningsLeaders.length < 10) {\n            winningsLeaders.push(_user);\n            _reorderWinningsLeaderboard(winningsLeaders.length - 1);\n        } else {\n            uint256 lowestWinnings = userStats[winningsLeaders[9]].totalWinnings;\n            if (userWinnings > lowestWinnings) {\n                winningsLeaders[9] = _user;\n                _reorderWinningsLeaderboard(9);\n            }\n        }\n        \n        emit LeaderboardUpdated(_user, \"winnings\");\n    }\n    \n    function _reorderWinningsLeaderboard(uint256 _startIndex) internal {\n        for (uint256 i = _startIndex; i > 0; i--) {\n            uint256 currentWinnings = userStats[winningsLeaders[i]].totalWinnings;\n            uint256 previousWinnings = userStats[winningsLeaders[i-1]].totalWinnings;\n            \n            if (currentWinnings > previousWinnings) {\n                address temp = winningsLeaders[i];\n                winningsLeaders[i] = winningsLeaders[i-1];\n                winningsLeaders[i-1] = temp;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    function _updateAccuracyLeaderboard(address _user) internal {\n        UserStats memory stats = userStats[_user];\n        \n        // Only consider users with at least 5 predictions for accuracy leaderboard\n        if (stats.totalPredictions < 5) return;\n        \n        uint256 userAccuracy = (stats.correctPredictions * BASIS_POINTS) / stats.totalPredictions;\n        \n        for (uint256 i = 0; i < accuracyLeaders.length; i++) {\n            if (accuracyLeaders[i] == _user) {\n                _reorderAccuracyLeaderboard(i);\n                return;\n            }\n        }\n        \n        if (accuracyLeaders.length < 10) {\n            accuracyLeaders.push(_user);\n            _reorderAccuracyLeaderboard(accuracyLeaders.length - 1);\n        } else {\n            UserStats memory lowestStats = userStats[accuracyLeaders[9]];\n            uint256 lowestAccuracy = (lowestStats.correctPredictions * BASIS_POINTS) / lowestStats.totalPredictions;\n            \n            if (userAccuracy > lowestAccuracy) {\n                accuracyLeaders[9] = _user;\n                _reorderAccuracyLeaderboard(9);\n            }\n        }\n        \n        emit LeaderboardUpdated(_user, \"accuracy\");\n    }\n    \n    function _reorderAccuracyLeaderboard(uint256 _startIndex) internal {\n        for (uint256 i = _startIndex; i > 0; i--) {\n            UserStats memory currentStats = userStats[accuracyLeaders[i]];\n            UserStats memory previousStats = userStats[accuracyLeaders[i-1]];\n            \n            uint256 currentAccuracy = (currentStats.correctPredictions * BASIS_POINTS) / currentStats.totalPredictions;\n            uint256 previousAccuracy = (previousStats.correctPredictions * BASIS_POINTS) / previousStats.totalPredictions;\n            \n            if (currentAccuracy > previousAccuracy) {\n                address temp = accuracyLeaders[i];\n                accuracyLeaders[i] = accuracyLeaders[i-1];\n                accuracyLeaders[i-1] = temp;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    // View functions\n    function getPrediction(uint256 _predictionId) external view returns (\n        uint256 id,\n        string memory question,\n        string[] memory options,\n        uint256 entryFee,\n        uint256 prizePool,\n        uint256 endTime,\n        uint256 resolutionTime,\n        bool resolved,\n        uint256 winningOption,\n        bool active,\n        uint256 totalParticipants\n    ) {\n        Prediction memory pred = predictions[_predictionId];\n        return (\n            pred.id,\n            pred.question,\n            pred.options,\n            pred.entryFee,\n            pred.prizePool,\n            pred.endTime,\n            pred.resolutionTime,\n            pred.resolved,\n            pred.winningOption,\n            pred.active,\n            pred.totalParticipants\n        );\n    }\n    \n    function getUserPrediction(uint256 _predictionId, address _user) \n        external \n        view \n        returns (uint256 option, bool claimed, uint256 timestamp) \n    {\n        UserPrediction memory userPred = userPredictions[_predictionId][_user];\n        return (userPred.option, userPred.claimed, userPred.timestamp);\n    }\n    \n    function getOptionStats(uint256 _predictionId, uint256 _optionIndex) \n        external \n        view \n        returns (uint256 participantCount, uint256 percentage) \n    {\n        uint256 count = optionCounts[_predictionId][_optionIndex];\n        uint256 total = predictions[_predictionId].totalParticipants;\n        \n        if (total == 0) {\n            return (0, 0);\n        }\n        \n        uint256 percent = (count * BASIS_POINTS) / total;\n        return (count, percent);\n    }\n    \n    function getAllOptionStats(uint256 _predictionId) \n        external \n        view \n        returns (uint256[] memory counts, uint256[] memory percentages) \n    {\n        Prediction memory pred = predictions[_predictionId];\n        uint256 optionCount = pred.options.length;\n        \n        counts = new uint256[](optionCount);\n        percentages = new uint256[](optionCount);\n        \n        for (uint256 i = 0; i < optionCount; i++) {\n            counts[i] = optionCounts[_predictionId][i];\n            if (pred.totalParticipants > 0) {\n                percentages[i] = (counts[i] * BASIS_POINTS) / pred.totalParticipants;\n            }\n        }\n        \n        return (counts, percentages);\n    }\n    \n    function getUserParticipatedPredictions(address _user) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return userParticipatedPredictions[_user];\n    }\n    \n    function calculatePotentialWinnings(uint256 _predictionId) \n        external \n        view \n        returns (uint256[] memory potentialWinnings) \n    {\n        Prediction memory pred = predictions[_predictionId];\n        uint256 optionCount = pred.options.length;\n        \n        potentialWinnings = new uint256[](optionCount);\n        uint256 totalPrize = pred.prizePool;\n        uint256 platformFeeAmount = (totalPrize * platformFee) / BASIS_POINTS;\n        uint256 winnersShare = totalPrize - platformFeeAmount;\n        \n        for (uint256 i = 0; i < optionCount; i++) {\n            uint256 winnersCount = optionCounts[_predictionId][i];\n            if (winnersCount > 0) {\n                potentialWinnings[i] = winnersShare / winnersCount;\n            }\n        }\n        \n        return potentialWinnings;\n    }\n    \n    // Leaderboard view functions\n    function getStreakLeaderboard() external view returns (\n        address[] memory users,\n        uint256[] memory streaks,\n        uint256[] memory longestStreaks\n    ) {\n        uint256 length = streakLeaders.length;\n        users = new address[](length);\n        streaks = new uint256[](length);\n        longestStreaks = new uint256[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            users[i] = streakLeaders[i];\n            streaks[i] = userStats[streakLeaders[i]].currentStreak;\n            longestStreaks[i] = userStats[streakLeaders[i]].longestStreak;\n        }\n        \n        return (users, streaks, longestStreaks);\n    }\n    \n    function getWinningsLeaderboard() external view returns (\n        address[] memory users,\n        uint256[] memory totalWinnings,\n        uint256[] memory currentStreaks\n    ) {\n        uint256 length = winningsLeaders.length;\n        users = new address[](length);\n        totalWinnings = new uint256[](length);\n        currentStreaks = new uint256[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            users[i] = winningsLeaders[i];\n            totalWinnings[i] = userStats[winningsLeaders[i]].totalWinnings;\n            currentStreaks[i] = userStats[winningsLeaders[i]].currentStreak;\n        }\n        \n        return (users, totalWinnings, currentStreaks);\n    }\n    \n    function getAccuracyLeaderboard() external view returns (\n        address[] memory users,\n        uint256[] memory accuracyPercentages,\n        uint256[] memory totalPredictions\n    ) {\n        uint256 length = accuracyLeaders.length;\n        users = new address[](length);\n        accuracyPercentages = new uint256[](length);\n        totalPredictions = new uint256[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            users[i] = accuracyLeaders[i];\n            UserStats memory stats = userStats[accuracyLeaders[i]];\n            accuracyPercentages[i] = (stats.correctPredictions * BASIS_POINTS) / stats.totalPredictions;\n            totalPredictions[i] = stats.totalPredictions;\n        }\n        \n        return (users, accuracyPercentages, totalPredictions);\n    }\n    \n    function getUserStats(address _user) external view returns (\n        uint256 totalPredictions,\n        uint256 correctPredictions,\n        uint256 currentStreak,\n        uint256 longestStreak,\n        uint256 totalWinnings,\n        uint256 accuracyPercentage,\n        bool hasStreakSaver\n    ) {\n        UserStats memory stats = userStats[_user];\n        uint256 accuracy = stats.totalPredictions > 0 ? \n            (stats.correctPredictions * BASIS_POINTS) / stats.totalPredictions : 0;\n            \n        return (\n            stats.totalPredictions,\n            stats.correctPredictions,\n            stats.currentStreak,\n            stats.longestStreak,\n            stats.totalWinnings,\n            accuracy,\n            stats.hasStreakSaver\n        );\n    }\n    \n    function getStreakMultiplier(address _user) external view returns (uint256) {\n        return _calculateStreakMultiplier(_user);\n    }\n    \n    function getUserRank(address _user, string memory _leaderboardType) external view returns (uint256) {\n        if (keccak256(bytes(_leaderboardType)) == keccak256(bytes(\"streak\"))) {\n            for (uint256 i = 0; i < streakLeaders.length; i++) {\n                if (streakLeaders[i] == _user) return i + 1;\n            }\n        } else if (keccak256(bytes(_leaderboardType)) == keccak256(bytes(\"winnings\"))) {\n            for (uint256 i = 0; i < winningsLeaders.length; i++) {\n                if (winningsLeaders[i] == _user) return i + 1;\n            }\n        } else if (keccak256(bytes(_leaderboardType)) == keccak256(bytes(\"accuracy\"))) {\n            for (uint256 i = 0; i < accuracyLeaders.length; i++) {\n                if (accuracyLeaders[i] == _user) return i + 1;\n            }\n        }\n        return 0; // Not ranked\n    }\n    \n    // Admin functions\n    function setPlatformFee(uint256 _fee) external onlyOwner {\n        require(_fee <= 2000, \"Fee too high\"); // Max 20%\n        platformFee = _fee;\n    }\n    \n    function setStreakSaverPrice(uint256 _price) external onlyOwner {\n        streakSaverPrice = _price;\n    }\n    \n    function withdrawPlatformFees() external onlyOwner {\n        // Calculate total platform fees earned\n        uint256 balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    \n    function pausePrediction(uint256 _predictionId) external onlyOwner {\n        predictions[_predictionId].active = false;\n    }\n    \n    function unpausePrediction(uint256 _predictionId) external onlyOwner {\n        predictions[_predictionId].active = true;\n    }\n    \n    // Emergency function to resolve stuck predictions\n    function emergencyResolve(uint256 _predictionId, uint256 _winningOption) \n        external \n        onlyOwner \n    {\n        require(block.timestamp > predictions[_predictionId].resolutionTime + 7 days, \n                \"Use regular resolve function\");\n        \n        Prediction storage prediction = predictions[_predictionId];\n        require(!prediction.resolved, \"Already resolved\");\n        \n        prediction.resolved = true;\n        prediction.winningOption = _winningOption;\n        \n        emit PredictionResolved(\n            _predictionId, \n            _winningOption, \n            prediction.options[_winningOption],\n            optionCounts[_predictionId][_winningOption]\n        );\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ]
      }
    }
  }
}